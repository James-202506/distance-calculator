<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D六轴机器人手动操作 (高精度版)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #333;
            color: #fff;
        }
        #viewport {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* 新增: 坐标轴标签的样式 */
        .axis-label-text {
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 5px black; /* 给文字加一点黑色描边，使其更清晰 */
        }
        #control-panel {
            position: absolute; /* 改为绝对定位 */
            top: 20px;        /* 距离顶部20px */
            right: 20px;       /* 距离右侧20px */
            z-index: 10;
            background-color: rgba(40, 40, 40, 0.9);
            padding: 15px;
            border-radius: 15px;
            border: 1px solid #555;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            user-select: none; /* 防止文本被选中 */
        }
        .control-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .control-group.center {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .control-button {
            background-color: #5a5a5a;
            color: #fff;
            border: 1px solid #444;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            padding: 12px 0;
            cursor: pointer;
            transition: background-color 0.1s;
            text-align: center;
        }
        .control-button:hover {
            background-color: #6a6a6a;
        }
        .control-button:active {
            background-color: #007bff;
            border-color: #0056b3;
            transform: scale(0.95);
        }
        .control-button .axis-label {
            font-size: 20px;
        }
        .control-button .joint-label {
            font-size: 12px;
            color: #a0e0ff;
        }
        .mode-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #333;
            padding: 8px;
            border-radius: 8px;
        }
        .mode-selector label {
            margin: 4px 0;
            cursor: pointer;
            padding: 5px 15px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        .mode-selector input[type="radio"] {
            display: none;
        }
        .mode-selector input[type="radio"]:checked + label {
            background-color: #007bff;
            color: white;
            font-weight: bold;
        }
        .speed-control {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .speed-control label {
            font-size: 14px;
            margin-bottom: 5px;
        }
        .speed-control input[type="range"] {
            width: 100px;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.6;
        }
    </style>
</head>
<body>

    <div id="viewport"></div>

    <div id="info-panel">
        <div id="mode-display">模式: 关节 (Joint)</div>
        <div id="coords-display"></div>
    </div>

    <div id="control-panel">
        <!-- 左侧按钮组: X, Y, Z -->
        <div class="control-group">
            <button class="control-button" id="X+"><div class="axis-label">X+</div><div class="joint-label">J1+</div></button>
            <button class="control-button" id="X-"><div class="axis-label">X-</div><div class="joint-label">J1-</div></button>
            <button class="control-button" id="Y+"><div class="axis-label">Y+</div><div class="joint-label">J2+</div></button>
            <button class="control-button" id="Y-"><div class="axis-label">Y-</div><div class="joint-label">J2-</div></button>
            <button class="control-button" id="Z+"><div class="axis-label">Z+</div><div class="joint-label">J3+</div></button>
            <button class="control-button" id="Z-"><div class="axis-label">Z-</div><div class="joint-label">J3-</div></button>
        </div>

        <!-- 中间控制区: 模式与速度 -->
        <div class="control-group center">
            <div class="speed-control">
                <label for="speed-slider">手动速度</label>
                <input type="range" id="speed-slider" min="1" max="100" value="50">
            </div>
            <div class="mode-selector">
                <input type="radio" id="mode-joint" name="coord-mode" value="joint" checked>
                <label for="mode-joint">关节坐标</label>
                <input type="radio" id="mode-base" name="coord-mode" value="base">
                <label for="mode-base">基坐标</label>
            </div>
        </div>
        
        <!-- 右侧按钮组: A, B, C -->
        <div class="control-group">
            <button class="control-button" id="A+"><div class="axis-label">A+</div><div class="joint-label">J4+</div></button>
            <button class="control-button" id="A-"><div class="axis-label">A-</div><div class="joint-label">J4-</div></button>
            <button class="control-button" id="B+"><div class="axis-label">B+</div><div class="joint-label">J5+</div></button>
            <button class="control-button" id="B-"><div class="axis-label">B-</div><div class="joint-label">J5-</div></button>
            <button class="control-button" id="C+"><div class="axis-label">C+</div><div class="joint-label">J6+</div></button>
            <button class="control-button" id="C-"><div class="axis-label">C-</div><div class="joint-label">J6-</div></button>
        </div>
    </div>

    <!-- 导入 Three.js 库 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- 场景设置 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 2.5, 4);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('viewport').appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);

        // --- 灯光设置 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);
        
        // --- 辅助工具 ---
        const gridHelper = new THREE.GridHelper(10, 10);
        scene.add(gridHelper);
        const worldAxis = new THREE.AxesHelper(1);
        scene.add(worldAxis);

        const axisLabels = ['Y', 'Z', 'X']; // Y on Red(+X), Z on Green(+Y), X on Blue(+Z)
        const axisColors = ['#ff4d4d', '#4dff4d', '#4d4dff']; // Y(红), Z(绿), X(蓝)
        const axisPositions = [
            new THREE.Vector3(1.1, 0, 0), // Y label on three.js X axis
            new THREE.Vector3(0, 1.1, 0), // Z label on three.js Y axis
            new THREE.Vector3(0, 0, 1.1)  // X label on three.js Z axis
        ];

        axisLabels.forEach((text, i) => {
            const div = document.createElement('div');
            div.className = 'axis-label-text';
            div.textContent = text;
            div.style.color = axisColors[i];

            const label = new CSS2DObject(div);
            label.position.copy(axisPositions[i]);
            worldAxis.add(label);
        });

        // --- 机器人模型 ---
        const robot = new THREE.Group();
        scene.add(robot);
        // **修正**: 旋转整个机器人，使其在J1=0时指向X正方向(three.js的-Z方向)
        robot.rotation.y = Math.PI / 2; 

        const linkMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.5, roughness: 0.5 });
        const jointMaterial = new THREE.MeshStandardMaterial({ color: 0x0055aa });
        const baseHeight = 0.2, link1Height = 0.5, link2Length = 1.5, link3Length = 1.3, wristLength = 0.3;
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, baseHeight, 32), linkMaterial);
        robot.add(base);
        const joint1 = new THREE.Group();
        base.add(joint1);
        joint1.position.y = baseHeight / 2;
        const j1Indicator = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, baseHeight + 0.01, 32), jointMaterial);
        joint1.add(j1Indicator);
        const link1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, link1Height, 0.4), linkMaterial);
        link1.position.y = link1Height / 2;
        joint1.add(link1);
        const joint2 = new THREE.Group();
        link1.add(joint2);
        joint2.position.y = link1Height / 2;
        joint2.position.x = 0.2;
        const j2Indicator = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.6, 32), jointMaterial);
        j2Indicator.rotation.x = Math.PI / 2;
        joint2.add(j2Indicator);
        const link2 = new THREE.Mesh(new THREE.BoxGeometry(link2Length, 0.3, 0.3), linkMaterial);
        link2.position.x = link2Length / 2;
        joint2.add(link2);
        const joint3 = new THREE.Group();
        link2.add(joint3);
        joint3.position.x = link2Length / 2;
        const j3Indicator = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.5, 32), jointMaterial);
        j3Indicator.rotation.x = Math.PI / 2;
        joint3.add(j3Indicator);
        const link3 = new THREE.Mesh(new THREE.BoxGeometry(link3Length, 0.25, 0.25), linkMaterial);
        link3.position.x = link3Length / 2;
        joint3.add(link3);
        const joint4 = new THREE.Group();
        link3.add(joint4);
        joint4.position.x = link3Length / 2;
        const j4Indicator = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.4, 32), jointMaterial);
        j4Indicator.rotation.z = Math.PI / 2;
        joint4.add(j4Indicator);
        const link4 = new THREE.Mesh(new THREE.BoxGeometry(wristLength, 0.2, 0.2), linkMaterial);
        link4.position.x = wristLength / 2;
        joint4.add(link4);
        const joint5 = new THREE.Group();
        link4.add(joint5);
        joint5.position.x = wristLength / 2;
        const j5Indicator = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.3, 32), jointMaterial);
        j5Indicator.rotation.x = Math.PI / 2;
        joint5.add(j5Indicator);
        const link5 = new THREE.Mesh(new THREE.BoxGeometry(wristLength, 0.15, 0.15), linkMaterial);
        link5.position.x = wristLength / 2;
        joint5.add(link5);
        const joint6 = new THREE.Group();
        link5.add(joint6);
        joint6.position.x = wristLength/2;
        const endEffector = new THREE.Group(); // 法兰盘 (Tool0)
        joint6.add(endEffector);
        const flange = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.05, 32), jointMaterial);
        flange.rotation.z = Math.PI/2;
        endEffector.add(flange);
        
        const toolConeHeight = 0.2;
        const toolConeBaseOffset = 0.1;
        const tool = new THREE.Mesh(new THREE.ConeGeometry(0.05, toolConeHeight, 32), new THREE.MeshStandardMaterial({color: 0xffff00}));
        tool.position.x = toolConeBaseOffset;
        tool.rotation.z = -Math.PI / 2;
        endEffector.add(tool);
        
        const tcp = new THREE.Object3D();
        tcp.position.x = toolConeBaseOffset + toolConeHeight; // 精确定位TCP
        endEffector.add(tcp);

        const joints = [joint1, joint2, joint3, joint4, joint5, joint6];

        // --- 控制逻辑 ---
        const motionState = {};
        const buttons = document.querySelectorAll('.control-button');
        let controlMode = 'joint';
        let speed = 0.5;
        function updateSpeed() {
            const sliderValue = document.getElementById('speed-slider').value;
            speed = (sliderValue / 100) * 1.5;
        }
        document.getElementById('speed-slider').addEventListener('input', updateSpeed);
        updateSpeed();
        buttons.forEach(button => {
            const actionId = button.id;
            motionState[actionId] = false;
            const startMoving = () => { motionState[actionId] = true; };
            const stopMoving = () => { motionState[actionId] = false; };
            button.addEventListener('mousedown', startMoving);
            button.addEventListener('mouseup', stopMoving);
            button.addEventListener('mouseleave', stopMoving);
            button.addEventListener('touchstart', (e) => { e.preventDefault(); startMoving(); }, { passive: false });
            button.addEventListener('touchend', stopMoving);
            button.addEventListener('touchcancel', stopMoving);
        });
        document.querySelectorAll('input[name="coord-mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                controlMode = e.target.value;
                document.getElementById('mode-display').textContent = `模式: ${controlMode === 'joint' ? '关节 (Joint)' : '基坐标 (Base)'}`;
            });
        });

        const clock = new THREE.Clock();
        
        // --- 矩阵运算辅助函数 ---
        function invertMatrix(M) {
            if (M.length !== M[0].length) { return; }
            const n = M.length;
            const I = Array(n).fill(0).map(() => Array(n).fill(0));
            for (let i = 0; i < n; i++) I[i][i] = 1;
            const C = M.map((row, i) => [...row, ...I[i]]);
            for (let i = 0; i < n; i++) {
                let pivot = i;
                while (pivot < n && C[pivot][i] === 0) pivot++;
                if (pivot === n) return null;
                [C[i], C[pivot]] = [C[pivot], C[i]];
                let div = C[i][i];
                for (let j = i; j < 2 * n; j++) C[i][j] /= div;
                for (let k = 0; k < n; k++) {
                    if (k !== i) {
                        let mult = C[k][i];
                        for (let j = i; j < 2 * n; j++) C[k][j] -= mult * C[i][j];
                    }
                }
            }
            return C.map(row => row.slice(n));
        }
        function multiplyMatrices(A, B) {
            const rowsA = A.length, colsA = A[0].length, rowsB = B.length, colsB = B[0].length;
            if (colsA !== rowsB) return null;
            const C = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));
            for (let i = 0; i < rowsA; i++) for (let j = 0; j < colsB; j++) for (let k = 0; k < colsA; k++) C[i][j] += A[i][k] * B[k][j];
            return C;
        }
        function multiplyMatrixVector(M, V) {
            const rows = M.length, cols = M[0].length;
            if (cols !== V.length) return null;
            const R = Array(rows).fill(0);
            for (let i = 0; i < rows; i++) for (let j = 0; j < cols; j++) R[i] += M[i][j] * V[j];
            return R;
        }

        // --- 逆运动学 (阻尼最小二乘法 DLS) ---
        function solveIK_DLS(targetVelocity, delta) {
            const lambda = 0.1;
            const epsilon = 0.001;

            const jacobian = [];
            const initialPose = new THREE.Vector3();
            const initialQuat = new THREE.Quaternion();
            tcp.getWorldPosition(initialPose);
            tcp.getWorldQuaternion(initialQuat);
            
            for (let i = 0; i < 6; i++) {
                const axis = (i === 0) ? 'y' : (i === 3 || i === 5) ? 'x' : 'z';
                const originalAngle = joints[i].rotation[axis];
                joints[i].rotation[axis] += epsilon;
                
                const newPose = new THREE.Vector3();
                const newQuat = new THREE.Quaternion();
                tcp.getWorldPosition(newPose);
                tcp.getWorldQuaternion(newQuat);

                joints[i].rotation[axis] = originalAngle;
                
                const linearVel = newPose.clone().sub(initialPose).divideScalar(epsilon);
                const dQuat = newQuat.clone().multiply(initialQuat.clone().invert());
                const angularVel = new THREE.Vector3(dQuat.x * 2, dQuat.y * 2, dQuat.z * 2).divideScalar(epsilon);

                jacobian.push([linearVel.x, linearVel.y, linearVel.z, angularVel.x, angularVel.y, angularVel.z]);
            }

            const J = jacobian.map(row => [...row]);
            const J_T = [];
            for (let i = 0; i < 6; i++) {
                J_T[i] = [];
                for (let j = 0; j < 6; j++) J_T[i][j] = J[j][i];
            }

            const JJT = multiplyMatrices(J, J_T);
            const JJT_damped = JJT.map((row, i) => row.map((val, j) => val + (i === j ? lambda * lambda : 0)));
            const JJT_inv = invertMatrix(JJT_damped);
            if (!JJT_inv) return [0,0,0,0,0,0];

            const J_T_JJT_inv = multiplyMatrices(J_T, JJT_inv);
            const errorVector = targetVelocity.map(v => v * delta);
            const jointAngleChanges = multiplyMatrixVector(J_T_JJT_inv, errorVector);

            return jointAngleChanges;
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const delta = clock.getDelta();
            const moveStep = speed * delta;

            if (controlMode === 'joint') {
                if (motionState['X+']) joints[0].rotation.y += moveStep;
                if (motionState['X-']) joints[0].rotation.y -= moveStep;
                if (motionState['Y+']) joints[1].rotation.z += moveStep;
                if (motionState['Y-']) joints[1].rotation.z -= moveStep;
                if (motionState['Z+']) joints[2].rotation.z += moveStep;
                if (motionState['Z-']) joints[2].rotation.z -= moveStep;
                if (motionState['A+']) joints[3].rotation.x += moveStep;
                if (motionState['A-']) joints[3].rotation.x -= moveStep;
                if (motionState['B+']) joints[4].rotation.z += moveStep;
                if (motionState['B-']) joints[4].rotation.z -= moveStep;
                if (motionState['C+']) joints[5].rotation.x += moveStep;
                if (motionState['C-']) joints[5].rotation.x -= moveStep;
            } else { // 基坐标模式
                let targetVelocity = [0, 0, 0, 0, 0, 0]; // [vx, vy, vz, wx, wy, wz] in three.js coordinates
                
                if (motionState['X+']) targetVelocity[2] = -speed; // X+ (用户向前) -> -Z (three.js)
                if (motionState['X-']) targetVelocity[2] = speed;  // X- (用户向后) -> +Z (three.js)
                if (motionState['Y+']) targetVelocity[0] = speed;  // Y+ (用户向右) -> +X (three.js)
                if (motionState['Y-']) targetVelocity[0] = -speed;
                if (motionState['Z+']) targetVelocity[1] = speed;  // Z+ (用户向上) -> +Y (three.js)
                if (motionState['Z-']) targetVelocity[1] = -speed;

                // A, B, C 对应绕用户坐标系 Z, Y, X 旋转
                if (motionState['A+']) targetVelocity[4] = speed;  // A (绕Z_up) -> rotY (three.js)
                if (motionState['A-']) targetVelocity[4] = -speed;
                if (motionState['B+']) targetVelocity[3] = speed;  // B (绕Y_right) -> rotX (three.js)
                if (motionState['B-']) targetVelocity[3] = -speed;
                if (motionState['C+']) targetVelocity[5] = -speed; // C (绕X_fwd) -> rotZ- (three.js)
                if (motionState['C-']) targetVelocity[5] = speed;

                if (targetVelocity.some(v => v !== 0)) {
                    const jointChanges = solveIK_DLS(targetVelocity, delta);
                    
                    joints[0].rotation.y += jointChanges[0];
                    joints[1].rotation.z += jointChanges[1];
                    joints[2].rotation.z += jointChanges[2];
                    joints[3].rotation.x += jointChanges[3];
                    joints[4].rotation.z += jointChanges[4];
                    joints[5].rotation.x += jointChanges[5];
                }
            }

            updateInfoPanel();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
        
        // --- 更新信息面板 ---
        function updateInfoPanel() {
            const radToDeg = (rad) => (rad * 180 / Math.PI).toFixed(2);
            let html = `<b>关节角度 (°):</b><br/>`;
            html += `J1 (Y): ${radToDeg(joints[0].rotation.y)}<br/>`;
            html += `J2 (Z): ${radToDeg(joints[1].rotation.z)}<br/>`;
            html += `J3 (Z): ${radToDeg(joints[2].rotation.z)}<br/>`;
            html += `J4 (X): ${radToDeg(joints[3].rotation.x)}<br/>`;
            html += `J5 (Z): ${radToDeg(joints[4].rotation.z)}<br/>`;
            html += `J6 (X): ${radToDeg(joints[5].rotation.x)}<br/>`;
            
            const tcpPos = new THREE.Vector3();
            tcp.getWorldPosition(tcpPos);

            const tcpRot = new THREE.Euler();
            tcpRot.setFromQuaternion(tcp.getWorldQuaternion(new THREE.Quaternion()), 'XYZ');

            html += `<br/><b>基坐标 (TCP, mm):</b><br/>`;
            html += `X: ${(-tcpPos.z * 1000).toFixed(2)}<br/>`; // 用户 X 是 three.js -Z
            html += `Y: ${(tcpPos.x * 1000).toFixed(2)}<br/>`;  // 用户 Y 是 three.js X
            html += `Z: ${(tcpPos.y * 1000).toFixed(2)}<br/>`;  // 用户 Z 是 three.js Y
            html += `A (Z°): ${radToDeg(tcpRot.y)}<br/>`;      // 用户 A (绕Z) 是 three.js 绕Y
            html += `B (Y°): ${radToDeg(tcpRot.x)}<br/>`;      // 用户 B (绕Y) 是 three.js 绕X
            html += `C (X°): ${radToDeg(-tcpRot.z)}<br/>`;     // 用户 C (绕X) 是 three.js 绕-Z
            document.getElementById('coords-display').innerHTML = html;
        }

        // --- 窗口大小调整 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
